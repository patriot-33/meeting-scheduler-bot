from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler
from datetime import datetime, timedelta, date
import logging

from database import get_db, User, UserRole, UserStatus, Meeting, MeetingStatus
from services.meeting_service import MeetingService
from services.google_calendar import google_calendar_service
from services.reminder_service import ReminderService
from config import settings
from utils.decorators import require_registration

logger = logging.getLogger(__name__)

# –†—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –¥–Ω–µ–π –Ω–µ–¥–µ–ª–∏
RUSSIAN_WEEKDAYS = {
    'Monday': '–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫',
    'Tuesday': '–í—Ç–æ—Ä–Ω–∏–∫', 
    'Wednesday': '–°—Ä–µ–¥–∞',
    'Thursday': '–ß–µ—Ç–≤–µ—Ä–≥',
    'Friday': '–ü—è—Ç–Ω–∏—Ü–∞',
    'Saturday': '–°—É–±–±–æ—Ç–∞',
    'Sunday': '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ'
}

@require_registration
async def show_available_slots(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show available dates for meetings."""
    user_id = update.effective_user.id
    
    with get_db() as db:
        user = db.query(User).filter(User.telegram_id == user_id).first()
        
        if user.role != UserRole.MANAGER:
            await update.message.reply_text(
                "‚ùå –î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º –æ—Ç–¥–µ–ª–æ–≤."
            )
            return
        
        # Check user status
        if user.status != UserStatus.ACTIVE:
            await update.message.reply_text(
                "‚è∏ –í—ã –Ω–∞—Ö–æ–¥–∏—Ç–µ—Å—å –≤ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–º —Å—Ç–∞—Ç—É—Å–µ.\n"
                f"–î–ª—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –≤—Å—Ç—Ä–µ—á —Å–Ω–∞—á–∞–ª–∞ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç–∞—Ç—É—Å: /active"
            )
            return
    
    try:
        with get_db() as db:
            meeting_service = MeetingService(db)
            
            # Get available slots when owners are free
            available_slots = meeting_service.get_available_slots(days_ahead=14)
            
            if not available_slots:
                await update.message.reply_text(
                    "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∞ –±–ª–∏–∂–∞–π—à–∏–µ 2 –Ω–µ–¥–µ–ª–∏ –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤.\n\n"
                    "üïê –°–ª–æ—Ç—ã –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Å–≤–æ–±–æ–¥–Ω—ã –≤–ª–∞–¥–µ–ª—å—Ü—ã –±–∏–∑–Ω–µ—Å–∞.\n"
                    "üìû –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –∏—Ö —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
                )
                return
        
        # Create keyboard with available dates (only days, not time slots)
        keyboard = []
        message_text = "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å –¥–ª—è –≤—Å—Ç—Ä–µ—á–∏:\n\n"
        
        sorted_dates = sorted(available_slots.keys())
        
        for date_str in sorted_dates:
            slots = available_slots[date_str]
            if slots:  # Only show dates with available slots
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                english_day = date_obj.strftime('%A')
                russian_day = RUSSIAN_WEEKDAYS.get(english_day, english_day)
                formatted_date = date_obj.strftime('%d.%m.%Y')
                
                # Show day with number of available slots
                button_text = f"{russian_day}, {formatted_date} ({len(slots)} —Å–ª–æ—Ç–æ–≤)"
                callback_data = f"date_{date_str}"
                
                keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        
        if not keyboard:
            await update.message.reply_text(
                "–ù–∞ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–Ω–∏ –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤."
            )
            return
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            message_text,
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logger.error(f"Error showing available slots: {e}")
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ—Ç–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )

async def show_day_slots(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show available time slots for selected date."""
    query = update.callback_query
    await query.answer()
    
    # Extract date from callback data
    date_str = query.data.replace('date_', '')
    
    try:
        with get_db() as db:
            meeting_service = MeetingService(db)
            available_slots = meeting_service.get_available_slots(days_ahead=14)
            
            if date_str not in available_slots:
                await query.edit_message_text(
                    "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å —Å–ª–æ—Ç—ã –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã."
                )
                return
            
            slots = available_slots[date_str]
            if not slots:
                await query.edit_message_text(
                    "‚ùå –ù–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤."
                )
                return
            
            # Format date for display
            date_obj = datetime.strptime(date_str, '%Y-%m-%d')
            english_day = date_obj.strftime('%A')
            russian_day = RUSSIAN_WEEKDAYS.get(english_day, english_day)
            formatted_date = date_obj.strftime('%d.%m.%Y')
            
            # Create keyboard with time slots
            keyboard = []
            message_text = f"üïê –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –Ω–∞ {russian_day}, {formatted_date}:\n\n"
            
            # Group slots in rows of 3
            row = []
            for slot in slots:
                callback_data = f"book_{date_str}_{slot}"
                row.append(InlineKeyboardButton(slot, callback_data=callback_data))
                
                if len(row) == 3:  # Three time slots per row
                    keyboard.append(row)
                    row = []
            
            if row:  # Add remaining buttons
                keyboard.append(row)
            
            # Add back button
            keyboard.append([InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –¥–Ω—è", callback_data="back_to_dates")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                message_text,
                reply_markup=reply_markup
            )
            
    except Exception as e:
        logger.error(f"Error showing day slots: {e}")
        await query.edit_message_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ—Ç–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )

async def back_to_dates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Go back to date selection."""
    query = update.callback_query
    await query.answer()
    
    # Re-show the date selection
    await show_available_slots_inline(query)

async def show_available_slots_inline(query):
    """Helper function to show date selection inline."""
    try:
        with get_db() as db:
            meeting_service = MeetingService(db)
            available_slots = meeting_service.get_available_slots(days_ahead=14)
            
            if not available_slots:
                await query.edit_message_text(
                    "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤."
                )
                return
        
        # Create keyboard with available dates
        keyboard = []
        message_text = "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å –¥–ª—è –≤—Å—Ç—Ä–µ—á–∏:\n\n"
        
        sorted_dates = sorted(available_slots.keys())
        
        for date_str in sorted_dates:
            slots = available_slots[date_str]
            if slots:
                date_obj = datetime.strptime(date_str, '%Y-%m-%d')
                english_day = date_obj.strftime('%A')
                russian_day = RUSSIAN_WEEKDAYS.get(english_day, english_day)
                formatted_date = date_obj.strftime('%d.%m.%Y')
                
                button_text = f"{russian_day}, {formatted_date} ({len(slots)} —Å–ª–æ—Ç–æ–≤)"
                callback_data = f"date_{date_str}"
                
                keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            message_text,
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logger.error(f"Error showing available slots inline: {e}")
        await query.edit_message_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ—Ç–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )

async def book_meeting_slot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Book a specific meeting slot."""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    
    # Parse callback data: book_2025-01-15_14:00
    callback_parts = query.data.split('_')
    if len(callback_parts) != 3:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞ –≤ –¥–∞–Ω–Ω—ã—Ö —Å–ª–æ—Ç–∞.")
        return
        
    date_str = callback_parts[1]
    time_str = callback_parts[2]
    
    try:
        with get_db() as db:
            user = db.query(User).filter(User.telegram_id == user_id).first()
            if not user:
                await query.edit_message_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                return
            
            meeting_service = MeetingService(db)
            
            # Parse meeting datetime
            meeting_date = datetime.strptime(date_str, '%Y-%m-%d')
            time_obj = datetime.strptime(time_str, '%H:%M').time()
            meeting_datetime = datetime.combine(meeting_date.date(), time_obj)
            
            # Check if user already has a meeting this week
            week_start = meeting_date - timedelta(days=meeting_date.weekday())
            week_end = week_start + timedelta(days=6)
            
            existing_meeting = db.query(Meeting).filter(
                Meeting.manager_id == user.id,
                Meeting.scheduled_time >= week_start,
                Meeting.scheduled_time <= week_end,
                Meeting.status == MeetingStatus.SCHEDULED
            ).first()
            
            if existing_meeting:
                next_allowed = existing_meeting.scheduled_time + timedelta(days=7)
                await query.edit_message_text(
                    f"‚ö†Ô∏è –£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤—Å—Ç—Ä–µ—á–∞ –Ω–∞ —ç—Ç—É –Ω–µ–¥–µ–ª—é.\n"
                    f"–°–ª–µ–¥—É—é—â—É—é –≤—Å—Ç—Ä–µ—á—É –º–æ–∂–Ω–æ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –Ω–µ —Ä–∞–Ω–µ–µ {next_allowed.strftime('%d.%m.%Y')}."
                )
                return
        
        # Check slot availability using meeting service
        if not meeting_service.is_slot_available(meeting_datetime):
            await query.edit_message_text(
                "‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ—Ç —Å–ª–æ—Ç —É–∂–µ –∑–∞–Ω—è—Ç. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ –≤—Ä–µ–º—è."
            )
            return
        
        # Create meeting
        try:
            meeting = meeting_service.create_meeting(user.id, meeting_datetime)
            
            if meeting:
                # Format success message
                english_day = meeting_datetime.strftime('%A')
                russian_day = RUSSIAN_WEEKDAYS.get(english_day, english_day)
                formatted_date = meeting_datetime.strftime('%d.%m.%Y')
                
                success_message = (
                    f"‚úÖ –í—Å—Ç—Ä–µ—á–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞!\n\n"
                    f"üìÖ {russian_day}, {formatted_date}\n"
                    f"üïê {time_str}\n"
                    f"üë§ {user.first_name} {user.last_name}\n"
                    f"üè¢ {user.department.value}\n\n"
                )
                
                # Add Google Meet link if available
                if meeting.google_meet_link:
                    success_message += f"üîó [–°—Å—ã–ª–∫–∞ –Ω–∞ –≤—Å—Ç—Ä–µ—á—É]({meeting.google_meet_link})\n\n"
                
                success_message += (
                    "üìß –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞–º.\n"
                    "‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∑–∞ 7, 3 –∏ 1 –¥–µ–Ω—å –¥–æ –≤—Å—Ç—Ä–µ—á–∏."
                )
                
                await query.edit_message_text(
                    success_message,
                    parse_mode='Markdown',
                    disable_web_page_preview=True
                )
                
                logger.info(f"Meeting created successfully: {meeting.id}")
                
            else:
                await query.edit_message_text(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤—Å—Ç—Ä–µ—á—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                )
                
        except Exception as e:
            logger.error(f"Error creating meeting: {e}")
            await query.edit_message_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤—Å—Ç—Ä–µ—á–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )
                
    except Exception as e:
        logger.error(f"Error booking meeting: {e}")
        await query.edit_message_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏ –≤—Å—Ç—Ä–µ—á–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )

# Handler registration
def get_manager_handlers():
    """Return list of manager-related handlers."""
    return [
        CommandHandler('schedule', show_available_slots),
        CallbackQueryHandler(show_day_slots, pattern=r'^date_\d{4}-\d{2}-\d{2}$'),
        CallbackQueryHandler(back_to_dates, pattern='^back_to_dates$'),
        CallbackQueryHandler(book_meeting_slot, pattern=r'^book_\d{4}-\d{2}-\d{2}_\d{2}:\d{2}$'),
    ]